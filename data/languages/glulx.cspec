<?xml version="1.0" encoding="UTF-8"?>

<!-- See Relax specification: Ghidra/Framework/SoftwareModeling/data/languages/compiler_spec.rxg -->

<compiler_spec>
  <data_organization>
	<pointer_size value="4" />
  </data_organization>
  
  <global>
    <range space="mem" />
  </global>
  
  <!-- JVM has a return_address register but does not declare a <returnaddress> in its cspec, so....
       ... We'll follow their lead.
  <returnaddress>
  	<register name="RA" />
  </returnaddress>
  -->
  
  <!-- XXX: Althrough Glulx uses a positive-growth stack, we declare "negative" here to avoid Ghidra issues. -->
  <stackpointer register="SP" space="vmstack" growth="positive" />
  
  <default_proto>
  	<!-- TODO: find a way to decide call convention based on func type C0 or C1 -->
  	<!-- C1 (i.e. __localargs) is the most common -->
	  <prototype name="__localargs" extrapop="unknown" stackshift="0">
	      <input>
	        <pentry minsize="1" maxsize="500" align="4">
	        	<!-- TODO: special handling for 1- and 2-byte locals? But those probably never occur. -->
	        	<!-- The offset attribute cancels out maxsize="500", so arguments start at local:0. -->
	          <addr offset="0xfffffe0c" space="stack" />
	        </pentry>
	      </input>
	      <output>
	      	<pentry minsize="1" maxsize="4" align="4" extension="inttype">
	      		<register name="RET" />
	      	</pentry>
	      </output>
	      <unaffected>
	        <register name="SP"/>
	      </unaffected>
	      <pcode inject="uponentry" dynamic="true" /> <!-- Injected dynamically by PcodeInjectLibraryGlulx -->
	        <!-- This first range lists the permissible stack offsets
	             that can be used as scratch and/or local variables  -->
			<localrange>
		          <range space="stack" first="0x0" last="0xf"/>
			</localrange>
	  </prototype>
	</default_proto>
	
</compiler_spec>
