# sleigh include file for Skeleton language instructions

define token opbyte (8)
   opc     = (0,7)
;

# contains a pair of operand types in the lo/hi 4 bits
define token opertypes (8)
   opty0 = (0,3)
   opty1 = (4,7)
   opty2 = (0,3)
   opty3 = (4,7)
   opty4 = (0,3)
   opty5 = (4,7)
   opty6 = (0,3)
   opty7 = (4,7)
;

define token data8 (8)
   imm8		= (0,7)
   sign8	= (7,7)
   simm8	= (0,7) signed
;

define token data16 (16)
   imm16        = (0,15)
   sign16		= (15,15)
   simm16		= (0,15) signed
;

define token data32 (32)
   imm32 = (0,31)
   sign32 = (31,31)
   simm32 = (0,31) signed
;

define pcodeop fnpush;
define pcodeop fncalln;
define pcodeop quit;
define pcodeop random;
define pcodeop restoreundo;
define pcodeop gestalt;
define pcodeop glk;
define pcodeop getmemsize;
define pcodeop binarysearch;
define pcodeop setiosys;
define pcodeop aloadbit;
define pcodeop astorebit;
define pcodeop streamstr;
define pcodeop streamchar;
define pcodeop streamunichar;
define pcodeop streamnum;
define pcodeop _TODO_;

################################################################
# Macros
################################################################

macro push(val) {
	*[vmstack]:4 SP = val;
	SP = SP + 4;
}

macro pop(val) {
	SP = SP - 4;
	val = *[vmstack]:4 SP;
}

################################################################

Imm8: imm8 is imm8 { export *[const]:1 imm8; }
Imm16: imm16 is imm16 { export *[const]:2 imm16; }
Imm32: imm32 is imm32 { export *[const]:4 imm32; }

Local8: imm8 is imm8 { export *[local]:4 imm8; }

_1Operand:  is opty0 [ operType0 = opty0; ] {}
_2Operands: is opty0 & opty1 [ operType0 = opty0; operType1 = opty1; ] {}
_3Operands: is opty0 & opty1; opty2 [ operType0 = opty0; operType1 = opty1; operType2 = opty2; ] {}
_4Operands: is opty0 & opty1; opty2 & opty3 [ operType0 = opty0; operType1 = opty1; operType2 = opty2; operType3 = opty3; ] {}
_5Operands: is opty0 & opty1; opty2 & opty3; opty4 [ operType0 = opty0; operType1 = opty1; operType2 = opty2; operType3 = opty3; operType4 = opty4; ] {}
_8Operands: is opty0 & opty1; opty2 & opty3; opty4 & opty5; opty6 & opty7 [ operType0 = opty0; operType1 = opty1; operType2 = opty2; operType3 = opty3; operType4 = opty4; operType5 = opty5; operType6 = opty6; operType7 = opty7; ] {}

FetchOperType0: is epsilon [ currOperType = operType0; ] { }
FetchOperType1: is epsilon [ currOperType = operType1; ] { }
FetchOperType2: is epsilon [ currOperType = operType2; ] { }
FetchOperType3: is epsilon [ currOperType = operType3; ] { }
FetchOperType4: is epsilon [ currOperType = operType4; ] { }
FetchOperType5: is epsilon [ currOperType = operType5; ] { }
FetchOperType6: is epsilon [ currOperType = operType6; ] { }
FetchOperType7: is epsilon [ currOperType = operType7; ] { }

LOperand: "0"   is currOperType=0x0        { export 0:4; }
LOperand: Imm8  is currOperType=0x1; Imm8  { local val:4 = sext(Imm8); export val; }
LOperand: Imm16 is currOperType=0x2; Imm16 { local val:4 = sext(Imm16); export val; }
LOperand: Imm32 is currOperType=0x3; Imm32 { export Imm32; }
LOperand: "pop" is currOperType=0x8        { local val:4; pop(val); export val; }
LOperand: Local8 is currOperType=0x9; Local8 { export Local8; }
LOperand: Imm8  is currOperType=0xD; Imm8  { local addr:4 = RAMSTART + zext(Imm8); export *:4 addr; }
LOperand: Imm16 is currOperType=0xE; Imm16 { local addr:4 = RAMSTART + zext(Imm16); export *:4 addr; }
LOperand: Imm32 is currOperType=0xF; Imm32 { local addr:4 = RAMSTART + Imm32; export *:4 addr; }

# LOperand must be copied to a temp variable to avoid corruption when
# LOperand is parsed more than once in a single Glulx instruction.
# FIXME: The corruption seems to be a bug in Ghidra, or at least it is
# very unintuitive behavior.
LOperand0: LOperand is FetchOperType0; LOperand { local tmp:4 = LOperand; export tmp; }
LOperand1: LOperand is FetchOperType1; LOperand { local tmp:4 = LOperand; export tmp; }
LOperand2: LOperand is FetchOperType2; LOperand { local tmp:4 = LOperand; export tmp; }
LOperand3: LOperand is FetchOperType3; LOperand { local tmp:4 = LOperand; export tmp; }
LOperand4: LOperand is FetchOperType4; LOperand { local tmp:4 = LOperand; export tmp; }
LOperand5: LOperand is FetchOperType5; LOperand { local tmp:4 = LOperand; export tmp; }
LOperand6: LOperand is FetchOperType6; LOperand { local tmp:4 = LOperand; export tmp; }

SOperand:        is currOperType=0x0        { } # Discard
SOperand: "push" is currOperType=0x8        { push(OUT); }
SOperand: Local8 is currOperType=0x9; Local8 { Local8 = OUT; }
SOperand: Imm8   is currOperType=0xD; Imm8  { local addr:4 = RAMSTART + zext(Imm8); *:4 addr = OUT; }
SOperand: Imm16  is currOperType=0xE; Imm16 { local addr:4 = RAMSTART + zext(Imm16); *:4 addr = OUT; }

SOperand0: SOperand is FetchOperType0; SOperand { }
SOperand1: SOperand is FetchOperType1; SOperand { }
SOperand2: SOperand is FetchOperType2; SOperand { }
SOperand3: SOperand is FetchOperType3; SOperand { }
SOperand4: SOperand is FetchOperType4; SOperand { }
SOperand5: SOperand is FetchOperType5; SOperand { }
SOperand6: SOperand is FetchOperType6; SOperand { }
SOperand7: SOperand is FetchOperType7; SOperand { }

BrTargetOperand: "ret0" is currOperType=0x0             [ branchAction=$(BR_RET0); ]         { BRTARGET = inst_next; }
BrTargetOperand: "ret1" is currOperType=0x1; simm8=0x01 [ branchAction=$(BR_RET1); ]         { BRTARGET = inst_next; }
BrTargetOperand: target is currOperType=0x1; simm8      [ target = inst_next + simm8 - 2; ]  { BRTARGET = target; }
BrTargetOperand: target is currOperType=0x2; simm16     [ target = inst_next + simm16 - 2; ] { BRTARGET = target; }
BrTargetOperand: target is currOperType=0x3; imm32      [ target = inst_next + imm32 - 2; ]  { BRTARGET = target; }
# This constructor is required to work around a Ghidra bug where an old currOperType is used for matching.
# The new currOperType is used for parsing and building.
# FIXME: This seems to be a bug in Ghidra, or at least it is very unintuitive behavior.
BrTargetOperand: "***ERROR: UNKNOWN OPER TYPE***" currOperType is currOperType               { BRTARGET = inst_next; }

BrTargetOperand0: BrTargetOperand is FetchOperType0; BrTargetOperand { }
BrTargetOperand1: BrTargetOperand is FetchOperType1; BrTargetOperand { }
BrTargetOperand2: BrTargetOperand is FetchOperType2; BrTargetOperand { }

################################################################

funcLocals: is imm16=0x0000 [ inFuncBody=1; globalset(inst_next, inFuncBody); ] {
}

funcLocals: imm16 funcLocals is imm16; funcLocals {
}

:funcC0 funcLocals is inFuncBody=0 & opc=0xC0; funcLocals {
}

:funcC1 funcLocals is inFuncBody=0 & opc=0xC1; funcLocals {
}

:nop is inFuncBody=1 & opc=0x00 {
}

:add LOperand0 LOperand1 SOperand2 is inFuncBody=1 & opc=0x10; _3Operands; LOperand0; LOperand1; SOperand2 {
	OUT = LOperand0 + LOperand1;
	build SOperand2;
}

:sub LOperand0 LOperand1 SOperand2 is inFuncBody=1 & opc=0x11; _3Operands; LOperand0; LOperand1; SOperand2 {
	OUT = LOperand0 - LOperand1;
	build SOperand2;
}

:mul LOperand0 LOperand1 SOperand2 is inFuncBody=1 & opc=0x12; _3Operands; LOperand0; LOperand1; SOperand2 {
	OUT = LOperand0 * LOperand1;
	build SOperand2;
}

:div LOperand0 LOperand1 SOperand2 is inFuncBody=1 & opc=0x13; _3Operands; LOperand0; LOperand1; SOperand2 {
	OUT = LOperand0 s/ LOperand1;
	build SOperand2;
}

:div LOperand0 LOperand1 SOperand2
is inFuncBody=1 & opc=0x14; _3Operands; LOperand0; LOperand1; SOperand2 {
	OUT = LOperand0 s% LOperand1;
	build SOperand2;
}

:neg LOperand0 SOperand1
is inFuncBody=1 & opc=0x15; _2Operands; LOperand0; SOperand1 {
	OUT = -LOperand0;
	build SOperand1;
}

:bitand LOperand0 LOperand1 SOperand2
is inFuncBody=1 & opc=0x18; _3Operands; LOperand0; LOperand1; SOperand2 {
	OUT = LOperand0 & LOperand1;
	build SOperand2;
}

:bitor LOperand0 LOperand1 SOperand2
is inFuncBody=1 & opc=0x19; _3Operands; LOperand0; LOperand1; SOperand2 {
	OUT = LOperand0 | LOperand1;
	build SOperand2;
}

:bitnot LOperand0 SOperand1
is inFuncBody=1 & opc=0x1B; _2Operands; LOperand0; SOperand1 {
	OUT = ~LOperand0;
	build SOperand1;
}

:ushiftr LOperand0 LOperand1 SOperand2
is inFuncBody=1 & opc=0x1E; _3Operands; LOperand0; LOperand1; SOperand2 {
	OUT = LOperand0 >> LOperand1;
	build SOperand2;
}

BranchAction: is branchAction=$(BR_RET0) {
	if (!CMP) goto inst_next; # XXX: return cannot be placed in an if statement, so do this instead.
	RET = 0;
	return [RA];
}

BranchAction: is branchAction=$(BR_RET1) {
	if (!CMP) goto inst_next; # XXX: return cannot be placed in an if statement, so do this instead.
	RET = 1;
	return [RA];
}

BranchAction: is epsilon {
	if (!CMP) goto inst_next; # XXX: indirect branch cannot be placed in an if statement, so do this instead.
	goto [BRTARGET];
}

:jump BrTargetOperand0
is inFuncBody=1 & opc=0x20; _1Operand; BrTargetOperand0; BranchAction {
	CMP = 1;
	build BrTargetOperand0;
	build BranchAction;
}

:jz LOperand0 BrTargetOperand1
is inFuncBody=1 & opc=0x22; _2Operands; LOperand0; BrTargetOperand1; BranchAction {
	CMP = LOperand0 == 0;
	build BrTargetOperand1;
	build BranchAction;
}

:jnz LOperand0 BrTargetOperand1
is inFuncBody=1 & opc=0x23; _2Operands; LOperand0; BrTargetOperand1; BranchAction {
	CMP = LOperand0 != 0;
	build BrTargetOperand1;
	build BranchAction;
}

:jeq LOperand0 LOperand1 BrTargetOperand2
is inFuncBody=1 & opc=0x24; _3Operands; LOperand0; LOperand1; BrTargetOperand2; BranchAction {
	CMP = LOperand0 == LOperand1;
	build BrTargetOperand2;
	build BranchAction;
}

:jne LOperand0 LOperand1 BrTargetOperand2
is inFuncBody=1 & opc=0x25; _3Operands; LOperand0; LOperand1; BrTargetOperand2; BranchAction {
	CMP = LOperand0 != LOperand1;
	build BrTargetOperand2;
	build BranchAction;
}

:jlt LOperand0 LOperand1 BrTargetOperand2
is inFuncBody=1 & opc=0x26; _3Operands; LOperand0; LOperand1; BrTargetOperand2; BranchAction {
	CMP = LOperand0 s< LOperand1;
	build BrTargetOperand2;
	build BranchAction;
}

:jge LOperand0 LOperand1 BrTargetOperand2
is inFuncBody=1 & opc=0x27; _3Operands; LOperand0; LOperand1; BrTargetOperand2; BranchAction {
	local op0 = LOperand0;
	local op1 = LOperand1;
	CMP = op0 s>= op1;
	build BrTargetOperand2;
	build BranchAction;
}

:jgt LOperand0 LOperand1 BrTargetOperand2
is inFuncBody=1 & opc=0x28; _3Operands; LOperand0; LOperand1; BrTargetOperand2; BranchAction {
	CMP = LOperand0 s> LOperand1;
	build BrTargetOperand2;
	build BranchAction;
}

:jle LOperand0 LOperand1 BrTargetOperand2
is inFuncBody=1 & opc=0x29; _3Operands; LOperand0; LOperand1; BrTargetOperand2; BranchAction {
	CMP = LOperand0 s<= LOperand1;
	build BrTargetOperand2;
	build BranchAction;
}

:jgeu LOperand0 LOperand1 BrTargetOperand2
is inFuncBody=1 & opc=0x2B; _3Operands; LOperand0; LOperand1; BrTargetOperand2; BranchAction {
	CMP = LOperand0 >= LOperand1;
	build BrTargetOperand2;
	build BranchAction;
}

:call LOperand0 LOperand1 SOperand2
is inFuncBody=1 & opc=0x30; _3Operands; LOperand0; LOperand1; SOperand2 {
	build LOperand0;
	local n:4 = LOperand1;
	# FIXME: This doesn't decompile correctly at all.
<check>
	if (n == 0) goto <docall>;
	local param:4;
	pop(param);
	fnpush(param);
	n = n - 1;
	goto <check>;
<docall>
	local target:1 = *:1 LOperand0;
	OUT = fncalln(target, LOperand1);
	build SOperand2;
}

:return LOperand0 is inFuncBody=1 & opc=0x31; _1Operand; LOperand0 {
	RET = LOperand0;
	return [RA];
}

:copy LOperand0 SOperand1 is inFuncBody=1 & opc=0x40; _2Operands; LOperand0; SOperand1 {
	OUT = LOperand0;
	build SOperand1;
}

:aload LOperand0 LOperand1 SOperand2
is inFuncBody=1 & opc=0x48; _3Operands; LOperand0; LOperand1; SOperand2 {
	local addr:4 = LOperand0 + 4 * LOperand1;
	OUT = *:4 addr;
	build SOperand2;
}

:aloads LOperand0 LOperand1 SOperand2
is inFuncBody=1 & opc=0x49; _3Operands; LOperand0; LOperand1; SOperand2 {
	local addr:4 = LOperand0 + 2 * LOperand1;
	OUT = zext(*:2 addr);
	build SOperand2;
}

:aloadb LOperand0 LOperand1 SOperand2
is inFuncBody=1 & opc=0x4A; _3Operands; LOperand0; LOperand1; SOperand2 {
	local addr:4 = LOperand0 + LOperand1;
	OUT = zext(*:1 addr);
	build SOperand2;
}

:aloadbit LOperand0 LOperand1 SOperand2
is inFuncBody=1 & opc=0x4B; _3Operands; LOperand0; LOperand1; SOperand2 {
	OUT = aloadbit(LOperand0, LOperand1);
	build SOperand2;
}

:astore LOperand0 LOperand1 LOperand2
is inFuncBody=1 & opc=0x4C; _3Operands; LOperand0; LOperand1; LOperand2 {
	local addr:4 = LOperand0 + 4 * LOperand1;
	*:4 addr = LOperand2;
}

:astores LOperand0 LOperand1 LOperand2
is inFuncBody=1 & opc=0x4D; _3Operands; LOperand0; LOperand1; LOperand2 {
	local addr:4 = LOperand0 + 2 * LOperand1;
	# FIXME: decompilation shows 4 bytes are written
	*:2 addr = LOperand2;
}

:astoreb LOperand0 LOperand1 LOperand2
is inFuncBody=1 & opc=0x4E; _3Operands; LOperand0; LOperand1; LOperand2 {
	local addr:4 = LOperand0 + LOperand1;
	*:1 addr = LOperand2;
}

:astorebit LOperand0 LOperand1 LOperand2
is inFuncBody=1 & opc=0x4F; _3Operands; LOperand0; LOperand1; LOperand2 {
	# TODO: don't use custom pcodeop?
	astorebit(LOperand0, LOperand1, LOperand2);
}

:stkcopy LOperand0
is inFuncBody=1 & opc=0x54; _1Operand; LOperand0 {
	build LOperand0; # If L1 uses the stack pop mode, the stkcopy is counted after L1 is popped.
	local count:4 = LOperand0;
	local src:4 = SP - (4 * count);
<loop>
	if (count == 0) goto inst_next;
	local val:4 = *[vmstack]:4 src;
	push(val);
	src = src + 4;
	count = count - 1;
	goto <loop>;
}

:streamchar LOperand0 is inFuncBody=1 & opc=0x70; _1Operand; LOperand0 {
	streamchar(LOperand0);
}

:streamnum LOperand0 is inFuncBody=1 & opc=0x71; _1Operand; LOperand0 {
	streamnum(LOperand0);
}

:streamstr LOperand0 is inFuncBody=1 & opc=0x72; _1Operand; LOperand0 {
	streamstr(LOperand0);
}

:streamunichar LOperand0 is inFuncBody=1 & opc=0x73; _1Operand; LOperand0 {
	streamunichar(LOperand0);
}

:gestalt LOperand0 LOperand1 SOperand2
is inFuncBody & opc=0x81; opc=0x00; _3Operands; LOperand0; LOperand1; SOperand2 {
	OUT = gestalt(LOperand0, LOperand1);
	build SOperand2;
}

:getmemsize SOperand0
is inFuncBody=1 & opc=0x81; opc=0x02; _1Operand; SOperand0 {
	OUT = getmemsize();
	build SOperand0;
}

:random LOperand0 SOperand1
is inFuncBody=1 & opc=0x81; opc=0x10; _2Operands; LOperand0; SOperand1 {
	OUT = random(LOperand0);
	build SOperand1;
}

:quit
is inFuncBody=1 & opc=0x81; opc=0x20 {
	tmp:4 = quit();
	return [tmp];
}

:restoreundo LOperand0
is inFuncBody=1 & opc=0x81; opc=0x26; _1Operand; LOperand0 {
	tmp:4 = restoreundo();
	return [tmp];
}

:glk LOperand0 LOperand1 SOperand2
is inFuncBody=1 & opc=0x81; opc=0x30; _3Operands; LOperand0; LOperand1; SOperand2 {
	OUT = glk(LOperand0, LOperand1);
	build SOperand2;	
}

:setiosys LOperand0 LOperand1
is inFuncBody=1 & opc=0x81; opc=0x49; _2Operands; LOperand0; LOperand1 {
	setiosys(LOperand0, LOperand1);
}

:binarysearch LOperand0 LOperand1 LOperand2 LOperand3 LOperand4 LOperand5 LOperand6 SOperand7
is inFuncBody=1 & opc=0x81; opc=0x51; _8Operands; LOperand0; LOperand1; LOperand2; LOperand3; LOperand4; LOperand5; LOperand6; SOperand7 {
	OUT = binarysearch(LOperand0, LOperand1, LOperand2, LOperand3, LOperand4, LOperand5, LOperand6);
	build SOperand7;
}

:callf LOperand0 SOperand1
is inFuncBody=1 & opc=0x81; opc=0x60; _2Operands; LOperand0; SOperand1 {
	local oldsp:4 = SP;
	local target:4 = LOperand0;
	call [target];
	OUT = RET;
	SP = oldsp;
	build SOperand1;
}

:callfi LOperand0 LOperand1 SOperand2
is inFuncBody=1 & opc=0x81; opc=0x61; _3Operands; LOperand0; LOperand1; SOperand2 {
	local oldsp:4 = SP;
	push(LOperand1);
	local target:4 = LOperand0;
	call [target];
	OUT = RET;
	SP = oldsp;
	build SOperand2;
}

:callfii LOperand0 LOperand1 LOperand2 SOperand3
is inFuncBody=1 & opc=0x81; opc=0x62; _4Operands; LOperand0; LOperand1; LOperand2; SOperand3 {
	local oldsp:4 = SP;
	push(LOperand2);
	push(LOperand1);
	local target:4 = LOperand0;
	call [target];
	OUT = RET;
	SP = oldsp;
	build SOperand3;
}

:callfiii LOperand0 LOperand1 LOperand2 LOperand3 SOperand4
is inFuncBody=1 & opc=0x81; opc=0x63; _5Operands; LOperand0; LOperand1; LOperand2; LOperand3; SOperand4 {
	local oldsp:4 = SP;
	push(LOperand3);
	push(LOperand2);
	push(LOperand1);
	local target:4 = LOperand0;
	call [target];
	OUT = RET;
	SP = oldsp;
	build SOperand4;
}
